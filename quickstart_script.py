#!/usr/bin/env python3
"""
YMERA Communication System - Quick Start Script
Automated setup and deployment for production-ready communication system
"""

import os
import sys
import subprocess
import asyncio
from pathlib import Path
from typing import Dict, List, Optional
import json

class Colors:
    """ANSI color codes"""
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    END = '\033[0m'
    BOLD = '\033[1m'

def print_header(text: str):
    """Print formatted header"""
    print(f"\n{Colors.BOLD}{Colors.BLUE}{'='*60}{Colors.END}")
    print(f"{Colors.BOLD}{Colors.BLUE}{text.center(60)}{Colors.END}")
    print(f"{Colors.BOLD}{Colors.BLUE}{'='*60}{Colors.END}\n")

def print_success(text: str):
    """Print success message"""
    print(f"{Colors.GREEN}✓ {text}{Colors.END}")

def print_error(text: str):
    """Print error message"""
    print(f"{Colors.RED}✗ {text}{Colors.END}")

def print_warning(text: str):
    """Print warning message"""
    print(f"{Colors.YELLOW}⚠ {text}{Colors.END}")

def print_info(text: str):
    """Print info message"""
    print(f"{Colors.BLUE}ℹ {text}{Colors.END}")

class QuickStart:
    """Quick start deployment manager"""
    
    def __init__(self):
        self.project_root = Path.cwd()
        self.backend_path = self.project_root / "backend" / "app"
        self.comm_path = self.backend_path / "COMMUNICATION_COORDINATION"
        self.errors = []
        self.warnings = []
    
    def run_command(self, cmd: List[str], cwd: Optional[Path] = None) -> bool:
        """Run shell command and return success status"""
        try:
            result = subprocess.run(
                cmd,
                cwd=cwd or self.project_root,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode != 0:
                self.errors.append(f"Command failed: {' '.join(cmd)}\n{result.stderr}")
                return False
            
            return True
        except Exception as e:
            self.errors.append(f"Command error: {' '.join(cmd)}\n{str(e)}")
            return False
    
    def check_prerequisites(self) -> bool:
        """Check if all prerequisites are installed"""
        print_header("Checking Prerequisites")
        
        prereqs = {
            "python": ["python", "--version"],
            "redis": ["redis-cli", "--version"],
            "docker": ["docker", "--version"],
            "kubectl": ["kubectl", "version", "--client"],
        }
        
        all_ok = True
        for name, cmd in prereqs.items():
            if self.run_command(cmd):
                print_success(f"{name} is installed")
            else:
                if name in ["docker", "kubectl"]:
                    print_warning(f"{name} not found (optional for local deployment)")
                else:
                    print_error(f"{name} is NOT installed (required)")
                    all_ok = False
        
        return all_ok
    
    def create_env_file(self) -> bool:
        """Create .env file with required configuration"""
        print_header("Creating Environment Configuration")
        
        env_path = self.project_root / ".env"
        
        if env_path.exists():
            print_warning(".env file already exists, backing up...")
            backup_path = env_path.with_suffix('.env.backup')
            env_path.rename(backup_path)
            print_info(f"Backup created: {backup_path}")
        
        env_content = """# YMERA Communication System Configuration
# Generated by quickstart script

# Redis Configuration
REDIS_URL=redis://localhost:6379
REDIS_PASSWORD=change_this_in_production
MAX_REDIS_CONNECTIONS=100

# Message Broker Configuration
MESSAGE_TTL=3600
ENABLE_ENCRYPTION=true
MESSAGE_ENCRYPTION_KEY=generate_before_production
MESSAGE_SIGNING_KEY=generate_before_production

# Task Dispatcher Configuration
MAX_CONCURRENT_TASKS=1000
TASK_TIMEOUT_DEFAULT=300
ENABLE_TASK_RETRY=true
ENABLE_LEARNING_OPTIMIZATION=true

# Response Aggregator Configuration
MAX_CONCURRENT_AGGREGATIONS=1000
DEFAULT_RESPONSE_TIMEOUT=300
ENABLE_QUALITY_SCORING=true
ENABLE_AGENT_REPUTATION=true

# Application Configuration
LOG_LEVEL=INFO
STRUCTLOG_ENABLED=true
DEBUG=false

# Security
SECRET_KEY=generate_before_production
ALLOWED_HOSTS=localhost,127.0.0.1

# Monitoring
PROMETHEUS_ENABLED=true
METRICS_PORT=9090
"""
        
        try:
            with open(env_path, 'w') as f:
                f.write(env_content)
            print_success(f"Created .env file at {env_path}")
            print_warning("⚠️  IMPORTANT: Update security keys before production deployment!")
            return True
        except Exception as e:
            print_error(f"Failed to create .env file: {e}")
            return False
    
    def install_dependencies(self) -> bool:
        """Install Python dependencies"""
        print_header("Installing Dependencies")
        
        requirements = """aioredis>=2.0.1
structlog>=23.1.0
fastapi>=0.104.1
uvicorn[standard]>=0.24.0
pydantic>=2.5.0
python-multipart>=0.0.6
python-jose[cryptography]>=3.3.0
cryptography>=41.0.7
redis>=5.0.1
pytest>=7.4.3
pytest-asyncio>=0.21.1
httpx>=0.25.2
"""
        
        req_path = self.project_root / "requirements.txt"
        
        try:
            with open(req_path, 'w') as f:
                f.write(requirements)
            
            print_info("Installing packages (this may take a few minutes)...")
            
            if self.run_command(["pip", "install", "-r", "requirements.txt"]):
                print_success("All dependencies installed successfully")
                return True
            else:
                print_error("Failed to install dependencies")
                return False
        except Exception as e:
            print_error(f"Error installing dependencies: {e}")
            return False
    
    def verify_files(self) -> bool:
        """Verify all required files exist"""
        print_header("Verifying System Files")
        
        required_files = [
            "task_dispatcher.py",
            "response_aggregator.py",
            "message_broker.py",
            "communication_protocols.py",
            "agent_registry.py",
        ]
        
        all_exist = True
        for filename in required_files:
            filepath = self.comm_path / filename
            if filepath.exists():
                print_success(f"Found {filename}")
            else:
                print_error(f"Missing {filename}")
                all_exist = False
        
        return all_exist
    
    def compile_python_files(self) -> bool:
        """Compile Python files to check for syntax errors"""
        print_header("Compiling Python Files")
        
        python_files = list(self.comm_path.glob("*.py"))
        
        all_compiled = True
        for filepath in python_files:
            if self.run_command(["python", "-m", "py_compile", str(filepath)]):
                print_success(f"Compiled {filepath.name}")
            else:
                print_error(f"Syntax error in {filepath.name}")
                all_compiled = False
        
        return all_compiled
    
    def start_redis(self) -> bool:
        """Start Redis server"""
        print_header("Starting Redis Server")
        
        # Check if Redis is already running
        if self.run_command(["redis-cli", "ping"]):
            print_success("Redis is already running")
            return True
        
        print_info("Starting Redis server...")
        
        # Try to start Redis
        try:
            subprocess.Popen(
                ["redis-server", "--daemonize", "yes"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            
            # Wait for Redis to start
            import time
            for i in range(10):
                if self.run_command(["redis-cli", "ping"]):
                    print_success("Redis server started successfully")
                    return True
                time.sleep(1)
            
            print_error("Redis server failed to start")
            return False
        except Exception as e:
            print_error(f"Failed to start Redis: {e}")
            return False
    
    def run_tests(self) -> bool:
        """Run test suite"""
        print_header("Running Tests")
        
        test_path = self.project_root / "tests"
        
        if not test_path.exists():
            print_warning("No tests directory found, skipping tests")
            return True
        
        print_info("Running unit tests...")
        if self.run_command(["pytest", "tests/unit", "-v"], cwd=self.project_root):
            print_success("Unit tests passed")
        else:
            print_warning("Some unit tests failed (this is OK for initial setup)")
        
        print_info("Running integration tests...")
        if self.run_command(["pytest", "tests/integration", "-v"], cwd=self.project_root):
            print_success("Integration tests passed")
        else:
            print_warning("Some integration tests failed (this is OK for initial setup)")
        
        return True
    
    def create_docker_compose(self) -> bool:
        """Create docker-compose.yml for easy deployment"""
        print_header("Creating Docker Configuration")
        
        docker_compose = """version: '3.8'

services:
  redis:
    image: redis:7-alpine
    container_name: ymera-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - ymera-network

  ymera-backend:
    build: .
    container_name: ymera-backend
    ports:
      - "8000:8000"
    environment:
      - REDIS_URL=redis://redis:6379
      - MAX_CONNECTIONS=100
      - MESSAGE_TTL=3600
    depends_on:
      redis:
        condition: service_healthy
    volumes:
      - ./backend:/app/backend
      - ./logs:/app/logs
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health/communication"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - ymera-network
    restart: unless-stopped

volumes:
  redis_data:

networks:
  ymera-network:
    driver: bridge
"""
        
        compose_path = self.project_root / "docker-compose.yml"
        
        try:
            with open(compose_path, 'w') as f:
                f.write(docker_compose)
            print_success(f"Created docker-compose.yml")
            return True
        except Exception as e:
            print_error(f"Failed to create docker-compose.yml: {e}")
            return False
    
    def create_systemd_service(self) -> bool:
        """Create systemd service file for production deployment"""
        print_header("Creating Systemd Service")
        
        service_content = f"""[Unit]
Description=YMERA Communication System
After=network.target redis.service
Requires=redis.service

[Service]
Type=simple
User={os.getenv('USER', 'ymera')}
WorkingDirectory={self.project_root}
Environment="PATH={self.project_root}/venv/bin"
EnvironmentFile={self.project_root}/.env
ExecStart={self.project_root}/venv/bin/uvicorn main:app --host 0.0.0.0 --port 8000
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
"""
        
        service_path = self.project_root / "ymera-communication.service"
        
        try:
            with open(service_path, 'w') as f:
                f.write(service_content)
            print_success(f"Created systemd service file at {service_path}")
            print_info("To install: sudo cp ymera-communication.service /etc/systemd/system/")
            print_info("Then: sudo systemctl enable ymera-communication")
            print_info("Start: sudo systemctl start ymera-communication")
            return True
        except Exception as e:
            print_error(f"Failed to create systemd service: {e}")
            return False
    
    def generate_security_keys(self) -> bool:
        """Generate security keys for production"""
        print_header("Generating Security Keys")
        
        try:
            from cryptography.fernet import Fernet
            
            encryption_key = Fernet.generate_key().decode()
            signing_key = Fernet.generate_key().decode()
            secret_key = Fernet.generate_key().decode()
            
            keys_file = self.project_root / "security_keys.txt"
            
            with open(keys_file, 'w') as f:
                f.write("# YMERA Security Keys - Keep these secret!\n")
                f.write(f"MESSAGE_ENCRYPTION_KEY={encryption_key}\n")
                f.write(f"MESSAGE_SIGNING_KEY={signing_key}\n")
                f.write(f"SECRET_KEY={secret_key}\n")
            
            os.chmod(keys_file, 0o600)  # Read/write for owner only
            
            print_success("Security keys generated")
            print_warning(f"⚠️  Keys saved to {keys_file}")
            print_warning("⚠️  Update .env file with these keys before production!")
            print_warning("⚠️  Keep security_keys.txt safe and DO NOT commit to git!")
            
            return True
        except Exception as e:
            print_error(f"Failed to generate security keys: {e}")
            return False
    
    def create_health_check_script(self) -> bool:
        """Create health check script"""
        print_header("Creating Health Check Script")
        
        health_check = """#!/bin/bash
# YMERA Communication System Health Check

echo "Checking YMERA Communication System Health..."

# Check Redis
if redis-cli ping > /dev/null 2>&1; then
    echo "✓ Redis is healthy"
else
    echo "✗ Redis is DOWN"
    exit 1
fi

# Check HTTP endpoint
if curl -sf http://localhost:8000/health/communication > /dev/null; then
    echo "✓ Communication system is healthy"
else
    echo "✗ Communication system is DOWN"
    exit 1
fi

# Check metrics
METRICS=$(curl -s http://localhost:8000/metrics/communication)
echo "Current Metrics:"
echo "$METRICS" | jq '.'

echo ""
echo "System is healthy! ✓"
exit 0
"""
        
        script_path = self.project_root / "health_check.sh"
        
        try:
            with open(script_path, 'w') as f:
                f.write(health_check)
            os.chmod(script_path, 0o755)  # Make executable
            print_success(f"Created health check script at {script_path}")
            print_info("Run with: ./health_check.sh")
            return True
        except Exception as e:
            print_error(f"Failed to create health check script: {e}")
            return False
    
    def print_next_steps(self):
        """Print next steps for user"""
        print_header("Setup Complete!")
        
        print("\n📋 Next Steps:\n")
        
        steps = [
            "1. Update .env file with your configuration",
            "2. Generate and update security keys from security_keys.txt",
            "3. Start the system:",
            "   • Local: uvicorn main:app --reload",
            "   • Docker: docker-compose up -d",
            "   • Production: sudo systemctl start ymera-communication",
            "",
            "4. Verify health:",
            "   • Run: ./health_check.sh",
            "   • Or visit: http://localhost:8000/health/communication",
            "",
            "5. View API docs: http://localhost:8000/docs",
            "",
            "6. Monitor logs:",
            "   • Local: tail -f logs/ymera.log",
            "   • Docker: docker-compose logs -f ymera-backend",
            "   • Systemd: sudo journalctl -u ymera-communication -f"
        ]
        
        for step in steps:
            if step.startswith("   •"):
                print(f"  {Colors.BLUE}{step}{Colors.END}")
            elif step == "":
                print()
            else:
                print(f"{Colors.GREEN}{step}{Colors.END}")
        
        if self.warnings:
            print(f"\n{Colors.YELLOW}⚠️  Warnings:{Colors.END}")
            for warning in self.warnings:
                print(f"  - {warning}")
        
        if self.errors:
            print(f"\n{Colors.RED}❌ Errors:{Colors.END}")
            for error in self.errors:
                print(f"  - {error}")
        
        print(f"\n{Colors.BOLD}Documentation:{Colors.END}")
        print("  • Deployment Guide: See the deployment_guide artifact")
        print("  • API Docs: http://localhost:8000/docs")
        print("  • Troubleshooting: Check logs and health endpoints")
        
        print(f"\n{Colors.GREEN}{Colors.BOLD}🚀 Your YMERA Communication System is ready!{Colors.END}\n")
    
    def run(self):
        """Run full setup process"""
        print_header("YMERA Communication System - Quick Start")
        print_info("This script will set up your production-ready communication system")
        
        steps = [
            ("Checking prerequisites", self.check_prerequisites),
            ("Creating environment configuration", self.create_env_file),
            ("Installing dependencies", self.install_dependencies),
            ("Verifying system files", self.verify_files),
            ("Compiling Python files", self.compile_python_files),
            ("Starting Redis server", self.start_redis),
            ("Running tests", self.run_tests),
            ("Creating Docker configuration", self.create_docker_compose),
            ("Creating systemd service", self.create_systemd_service),
            ("Generating security keys", self.generate_security_keys),
            ("Creating health check script", self.create_health_check_script),
        ]
        
        failed_steps = []
        
        for description, step_func in steps:
            try:
                if not step_func():
                    failed_steps.append(description)
            except Exception as e:
                print_error(f"Exception in {description}: {e}")
                failed_steps.append(description)
        
        if failed_steps:
            print_header("Setup Completed with Issues")
            print_warning("The following steps had issues:")
            for step in failed_steps:
                print(f"  - {step}")
            print_info("\nYou may need to manually complete these steps")
        
        self.print_next_steps()

def main():
    """Main entry point"""
    try:
        quickstart = QuickStart()
        quickstart.run()
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}Setup interrupted by user{Colors.END}")
        sys.exit(1)
    except Exception as e:
        print(f"\n{Colors.RED}Fatal error: {e}{Colors.END}")
        sys.exit(1)

if __name__ == "__main__":
    main()